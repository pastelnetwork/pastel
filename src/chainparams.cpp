// Copyright (c) 2010 Satoshi Nakamoto
// Copyright (c) 2009-2014 The Bitcoin Core developers
// Copyright (c) 2018-2022 The Pastel Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

/*
 ** 2020 December 25th **
 Genesis block for MainNet found
  merkle root hash: db59ee80098a38c8251e96e5358eeeb80f5c4e64790727803cab828fed0a9368
  header hash: 000081da84af725f5b4281b9a42d251f06715f14b86cb4cf9e59c2b9cf88b7eb
  nonce: 000000000000000000000000000000000000000000000000000000000000093a
  solution: 00947f5e3b1475daa892343d1473980dcdaef57c6000e21d83bbc5f92f7bc393e4e9e358367cdc9528f909436d7a16aa88cdf4d1115863e432f6c49f97ee25763e7bf50e2f2067ab1697fec04ebb9ae3fe1f170d033e19ed8e959be1823e006677c30e0c990179a5ea0966ac9ed2c81c545899e51edcdf062ba8179d615e12c1bf404c66fb0d650e9170ef92010867a48c5a363ecd03fcf92b968bf84076dc9ae0204339d15b0e1807cf8a8470990511146281b5fb1a92ad4c60f4e42a2819533f5214a7c6d0d7c43145c2869f5c4d1ccae20a0272233b91e75594c772f5d2d792a506d7dc2efc0bb302d30408ad7df1b7e5a07258a68e88e7983cda26172be6bcf015dbfb7de56716e80cbe2df071de18300e369274a46b5dc571c4c7e9d9c75311cc1bd3f826c2e173260eecdeee68b3c6e2cd5f422421b9229f2d27ff5ee0ab2699dfa6c35080501392365f5dd43e012a344001cfd52f54a884228a3cc54ddb1a5b694f26082f5c8e4c15858287428bb66d8c9a0f90bb71161102f265b9d44c8102bf75395d694efdac3f2e593c40efa7daa8ad7f2d9e99767000fb28c1e2f0149b771b9a6fecb6cd9e7d96cd668ba335077a31d79930dc280409e7b3ded4c919a0264a98607206988bd9b18d247f6a9b4353ab5b212562fe94ced901d7d8fd59be2c209bcfc4b02a35b6f945cf84dc61275c977e73c2029c1cb867b0627bc0c0c0dc15554168743bc97c8a5a49f7df8b6de8eb98e4a6c3a0f7cfc602df5c940d0465c92afd8951c57dfe6370c2da90868dcbf49743123774b00494c824ce1464c7c1db0196f971d7cd4e0a0b3213c705892fa9202236f817435ebc9bf705d2231a87cd319367e73e756abbd2e5f7b3bcb13fd9f21195637dc088620bb87f613850a0dba5a3b6ba199139f9364abd512371e20653a85026e5191950579c5e014efe11e31729adc5a38380c369efcd070cd80af530b871a8ef20e48f17d6f3a49b2e8b8ae20298d9a30391bc4b0097cf253d07e425347ae8d5252573217d03d955383b67df9de6d890e686f23a45fc0810a4fa04d090df4e92f457e8cbe2e816758d96479db9d9ff4e261f68921a23fae7ee86e13aec911e318334e2a8273c9d77547184e7e09cb56013c600a97d2c99bfd05d6595afe7dc3a07f5aa662c424d095e5a69d3b447099e690cdbd0dfdb0e91615a861e78da68c4db0e2336ffe7a808abe419e205950dc7f9a77ad556f8d93f13ba28fe8f86c3fc9a7c723dd6e1aece927cd95db531a2824341742245be5d334d6d64633d6cfeb80a4610fcbe45c051f472a4d41624453fd6322377fb2d37114556ec77075b0055974150579b0e61c2ab76411821f4917db212a880f58503a1973e8101f5551f2dc02aeab177e026ec8b94a50303dccd0b9f79b79c47e90529bbe4f618806f465433ef01daa0a2788d552a932d7c9c17d8550edfb7e6b39fc14540290a1adbfc8c10e43e9d81cbaa92fdea1176cb6f1d1f2b24595c5e5e888fd023f14ce3fbd74aec7ff4c953b280fdf4ad1af3c61a55945355f08e91c5697d6c18f6eb4e026d2deb51c0d855f72cf6f1558c68612406ab537d093b28642d97b08db079868fc5fb056a7552349c7947292b6674b9b55ea543115a6394f3e55bc53793f8593506246ebc1020afb9f23de08047f2c514d373143b0c13ba97e90ba6b027368987df037e1db694b05b2c3537047d091c95b89138fdc68f69df16ee720799421739c28480d9ecf6e77abc9440b445ea9694cf59b19407d24d0ce765e15d841fa9061ef57686f71db8e36b0e6b17cb5e64835fb4db64c3d1c9898988f2991e820f3a46ec214af03c8729b3f1eea633914eb9d5494c32389e9bf9a881adb6c7095d974b6b3f96d41d088c


Genesis block for TestNet found
  merkle root hash: ac375f272f2ac1f23f505a71ca33159e7d32993976cf91620b8363400c757161
  header hash: 0302f1ab449e6424f1ec076a6496b331fa664d8b95d866023ea6675bbb387f53
  nonce: 0000000000000000000000000000000000000000000000000000000000000025
  solution: 008c182882d3e546b05bf5c93b669b81f81d1715a310295f26e21f69af5050c133b745c285432c786b89170113757f8f9a5c876f62d30ae7335f546b5dc48f3c838e70558f66a1324644ae0af83006cf3ff9a9fa08c134b2178d4169f3a283d84054678681d77bfd20124501140310781ed2cc6256bcef194cb58dab2eac0bca87adb6d8f690e871b136fd3b2628e5d58c66221fe9e555facb32a07f34b682c2f987da795fba09920beab08ffc8af465744db6afba4859fde438d22fb81d4f91e2c5e1be091d9643124c68cc95c94633cbf11ecfb60626683a2d7426d544ee6a9f3e11513b08704544aee4a7956bef622ff7d72dee614e3974d2981212ae016c31466769a58e85cbf46955e1922b5515e3314ab6b5cf9e5f17640c5545ddfcbb0671b89b1259176003f8276ca98f8986317ffcb6f65c8f927fd0b9326416006b154c0ebeea7afeade9590ac0c158f46e068b29536697988ba1b253ee9237d0ef0394fd50c038114eeb5352c4d0d49803ee82fa90a10c03cd3df611d3f5c56c0eff17db59e34143cbb568eb67cdd1a8213a448d342d9f9dedc396ae1efed1e5e9deb5892b122bfacf00507b0c89a671763a210afc9ce1341ca5152d6afebb126f30efaab1d1743ae06a34e5d8baec1a4fb1219330866dec45529a5a2a96b94b7d94faa44aaf7772d8601493b82b784a92c70e763874d60d4806bf4349988fc1b0fbfd2585442c6be9a1ad96d54823a7c685fe9b99d2e07d8b3159efe1b2eba2faa6d31a982e724b10415b9c8592dbf0d469c1762a718bc2308bd30729d68463113236e683cdc495d90a373be90b4b432159db23275909c5cf793c3c19a9c03c51a0222592fd9911b3739b3168bab9eb2b7662eb3d502a456f768b91a8d033d534b457d53d1d0630a614c1045710baf8269bbad52a1275bec8f8dafe332f760cdb019ccc21981d21db45ebd4da0dfec989591d4d0b9f15bb5b7dd9aa8745afa3253ee044fefe68bdb72dbf23274755d488cf46b958e350d8d6c4b2878d15f94624d78519a0e2be2d4dd7d6025c6b3a75cee82e9d500438693a4ddcb2594a34462701e843b9e7b0b61ddb06d1c8d33d13c54d885d206d934443a26f545b3424384dbe70cc2582ab3c3ad69e6bbd45c1b6837365b43959fe6fb1af942ff52967fcb9766fe250f958b343036ce6019a57f47b49ae47c60853ab128ed0d879ce154fec8be990c41dff2c42287b9944a544cd4d00e4376bb6c70418ef18fd41156dfab551bdc8fab1a7ea468acf3f39ad572fceb79a33975c498334f4fff17a03de24c9b00e7ac5e3fff357823b03d10c221755d82941e320fbd7c8e127e8e34f99529bc917f316b70006dae2116fc8c761fa34a0ec6918408c51a2f2efa52eb76ce1daf6fc03eedf72fbedde274ebb077a22b901bca3a1bd116fc924642601867135134a665e1784481b82c186e29ebdb7f87650e3ef2276160312e42e07bf22ef5d936bc5a4f63c703dfc4bb32d557f4e400e6feec6d0893e38acb0039c39d8d312a36d5b5e0d072d8b6f3ea380cbc8cd808f00f2b5a8bb6271e1d30ac36918134741e19e8840ec834bf37471284d0eda265f648a38189d17c3b8b299dee28a06b109df70545083e305fa5ba589e4bab93b69d8e86b806ffec86b04e180919e9ce05eee7bf2bb70b5f4e5cc16f500ea15e3de802b91767abf48583dea6e9faf77a35e890309924645fe9d5f65171b63d797f475eee236fbed8713e0e2b217ce24fcd1b1a4352456e75da0d079defd07e8b1efdb4b324ca4292431afe6b621b255fc0dad5ffc8d6e435ac0af1bd937339dcfb2dedd54dc1beb103499dededfc9312a4a962bc0c5622337d15c510845e134c38f26fd9d8ad378a4346bb0d6bd87b8dd1d


Genesis block for RegTest found
  merkle root hash: e6d9b5038bb15366c806cefb34ad4922cee668ea1c887e9be8476f2c188dea50
  header hash: 065c1d8ea9abb121b8b12e4e483e46f60e743bb149de4bc82e4dd81598b99338
  nonce: 0000000000000000000000000000000000000000000000000000000000000039
  solution: 07b461d5f48e91b1fe4a65a112b513c1ad230a9bd4b8f79c069da636341051b3ff455393

 */
#include <cassert>
#include <optional>
#include <variant>
#include <vector>

#include <key_io.h>
#include <main.h>
#include <crypto/equihash.h>
#include <port_config.h>
#include <util.h>
#include <utilstrencodings.h>
#include <chainparamsseeds.h>

using namespace std;

constexpr unsigned int OVERWINTER_STARTING_BLOCK = 10;
constexpr unsigned int SAPLING_STARTING_BLOCK = 20;

static CBlock CreateGenesisBlock(const char* pszTimestamp, 
                                 const v_uint8 &genesisPubKey, 
                                 uint32_t nTime, 
                                 uint256 nNonce, 
                                 const v_uint8 &nSolution, 
                                 uint32_t nBits, 
                                 int32_t nVersion = 4, 
                                 const CAmount& genesisReward = 0)
{
    CMutableTransaction txNew;
    txNew.nVersion = 1;
    txNew.vin.resize(1);
    txNew.vout.resize(1);
    txNew.vin[0].scriptSig = CScript() << (int)nBits << CScriptNum(4) << v_uint8((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));
    txNew.vout[0].nValue = genesisReward;
    txNew.vout[0].scriptPubKey = CScript() << genesisPubKey << OP_CHECKSIG;

    CBlock genesis;
    genesis.nTime    = nTime;
    genesis.nBits    = nBits;
    genesis.nNonce   = nNonce;
    genesis.nSolution = nSolution;
    genesis.nVersion = nVersion;
    genesis.vtx.push_back(txNew);
    genesis.hashPrevBlock.SetNull();
    genesis.hashMerkleRoot = genesis.BuildMerkleTree();
    return genesis;
}

//#define MINE_GENESIS
#ifdef MINE_GENESIS
#define MINE_GENESIS_MAIN
#define MINE_GENESIS_TEST
#define MINE_GENESIS_REGT

namespace MineGenesis {
#include "pow/tromp/equi_miner.h"
static void __mineGenBlock(std::string network, bool tromp, unsigned int n, unsigned int k, CBlock *pblock)
{
    printf("Will be mining Genesis block for %s using %s solver\n", network.c_str(), tromp? "tromp": "default");

    pblock->nNonce.SetNull();
    pblock->nSolution.clear();

    arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);

    int counter = 0;
    bool bContinue = true;
    while (bContinue) {
        printf("\titteration %d\r", ++counter);
        fflush(stdout);

        // Hash state
        crypto_generichash_blake2b_state state;
        EhInitialiseState(n, k, state);

        // I = the block header minus nonce and solution.
        CEquihashInput I{*pblock};
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        ss << I;

        // H(I||...
        crypto_generichash_blake2b_update(&state, (unsigned char*)&ss[0], ss.size());

        // H(I||V||...
        crypto_generichash_blake2b_state curr_state;
        curr_state = state;
        crypto_generichash_blake2b_update(&curr_state,
                                            pblock->nNonce.begin(),
                                            pblock->nNonce.size());

        // (x_1, x_2, ...) = A(I, V, n, k)
        std::function<bool(v_uint8)> validBlock =
            [&network, &pblock, &hashTarget]
            (v_uint8 soln) {
            
            // Write the solution to the hash and compute the result.
            pblock->nSolution = soln;

            if (UintToArith256(pblock->GetHash()) > hashTarget) {
                return false;
            }
            printf("Genesis block for %s found  \n  merkle root hash: %s\n  header hash: %s\n  nonce: %s\n  solution: %s\n",
                                                        network.c_str(),
                                                        pblock->hashMerkleRoot.GetHex().c_str(),
                                                        pblock->GetHash().GetHex().c_str(), 
                                                        pblock->nNonce.GetHex().c_str(),
                                                        HexStr(pblock->nSolution).c_str());

            return true;
        };

        if (tromp) {
            equi eq(1);
            eq.setstate(&curr_state);

            // Intialization done, start algo driver.
            eq.digit0(0);
            eq.xfull = eq.bfull = eq.hfull = 0;
            eq.showbsizes(0);
            for (u32 r = 1; r < WK; r++) {
                (r&1) ? eq.digitodd(r, 0) : eq.digiteven(r, 0);
                eq.xfull = eq.bfull = eq.hfull = 0;
                eq.showbsizes(r);
            }
            eq.digitK(0);

            // Convert solution indices to byte array (decompress) and pass it to validBlock method.
            for (size_t s = 0; s < eq.nsols; s++) {
                LogPrint("pow", "Checking solution %d\n", s+1);
                std::vector<eh_index> index_vector(PROOFSIZE);
                for (size_t i = 0; i < PROOFSIZE; i++) {
                    index_vector[i] = eq.sols[s][i];
                }
                v_uint8 sol_char = GetMinimalFromIndices(index_vector, DIGITBITS);

                if (validBlock(sol_char)) {
                    // If we find a POW solution, do not try other solutions
                    // because they become invalid as we created a new block in blockchain.
                    bContinue = false;
                    break;
                }
            }
        } else if (EhOptimisedSolveUncancellable(n, k, curr_state, validBlock)) {
            break;
        }

        pblock->nNonce = ArithToUint256(UintToArith256(pblock->nNonce) + 1);
    }
}
}
#endif

/**
 * Build the genesis block. Note that the output of its generation
 * transaction cannot be spent since it did not originally exist in the
 * database (and is in any case of zero value).
 *
 * >>> from pyblake2 import blake2s
 *
 ** 2020 December 25th **
 * >>> 'Pascal' + blake2s(b'Forbes December 19th, 2020 Coinbase CEO Brian Armstrong Issues Serious Warning As Bitcoin Surges Toward $25,000 BTC#662960 00000000000000000000be30e71bfc16fd33accf815ba5450ff82b60c8a1dcb3 ETH#11525145 0x1b65b20dbeb981e81f86039f690cffb762ccc77e8594e0fb414ae23cea6c6d55 DJIA Dec 24, 2020 at 2:22 p.m. EST 30,199.87').hexdigest()
 * => Pascalfa9f9ecb4d2a411ce792e4e64324d91bd26f8376ca83dc914468e6b1c83cdb59
 *
 * nTime - epoc time
 * 12/25/2020 00:00:00 GMT = 1608854400
 *
 *
 * echo "Generating private key"
 * openssl ecparam -genkey -name secp256k1 -rand /dev/urandom -out $PRIVATE_KEY
 *
 * echo "Generating public key"
 * openssl ec -in $PRIVATE_KEY -pubout -out $PUBLIC_KEY
 *
 * echo "Generating BitCoin private key"
 * openssl ec -in $PRIVATE_KEY -outform DER|tail -c +8|head -c 32|xxd -p -c 32 > $BITCOIN_PRIVATE_KEY
 *
 * echo "Generating BitCoin public key"
 * openssl ec -in $PRIVATE_KEY -pubout -outform DER|tail -c 65|xxd -p -c 65 > $BITCOIN_PUBLIC_KEY


 */

// ** 2020 December 25th **
static const v_uint8 PastelGenesisPubKey = ParseHex("04b71877e98be12cf80216bdbf54afcac969cdb48e511d19a338ec9bb775e7a840fe64b93d319a6f028e5a9464c6fcf8a7fd2b958559991995c8bed5b5df136d02");
static const char* PastelGenesisTimestamp = "Pascalfa9f9ecb4d2a411ce792e4e64324d91bd26f8376ca83dc914468e6b1c83cdb59";
static const uint32_t EpocTime = 1608854400;

static const std::string MainnetNonce = "000000000000000000000000000000000000000000000000000000000000093a";
static const std::string MainnetSolution = "00947f5e3b1475daa892343d1473980dcdaef57c6000e21d83bbc5f92f7bc393e4e9e358367cdc9528f909436d7a16aa88cdf4d1115863e432f6c49f97ee25763e7bf50e2f2067ab1697fec04ebb9ae3fe1f170d033e19ed8e959be1823e006677c30e0c990179a5ea0966ac9ed2c81c545899e51edcdf062ba8179d615e12c1bf404c66fb0d650e9170ef92010867a48c5a363ecd03fcf92b968bf84076dc9ae0204339d15b0e1807cf8a8470990511146281b5fb1a92ad4c60f4e42a2819533f5214a7c6d0d7c43145c2869f5c4d1ccae20a0272233b91e75594c772f5d2d792a506d7dc2efc0bb302d30408ad7df1b7e5a07258a68e88e7983cda26172be6bcf015dbfb7de56716e80cbe2df071de18300e369274a46b5dc571c4c7e9d9c75311cc1bd3f826c2e173260eecdeee68b3c6e2cd5f422421b9229f2d27ff5ee0ab2699dfa6c35080501392365f5dd43e012a344001cfd52f54a884228a3cc54ddb1a5b694f26082f5c8e4c15858287428bb66d8c9a0f90bb71161102f265b9d44c8102bf75395d694efdac3f2e593c40efa7daa8ad7f2d9e99767000fb28c1e2f0149b771b9a6fecb6cd9e7d96cd668ba335077a31d79930dc280409e7b3ded4c919a0264a98607206988bd9b18d247f6a9b4353ab5b212562fe94ced901d7d8fd59be2c209bcfc4b02a35b6f945cf84dc61275c977e73c2029c1cb867b0627bc0c0c0dc15554168743bc97c8a5a49f7df8b6de8eb98e4a6c3a0f7cfc602df5c940d0465c92afd8951c57dfe6370c2da90868dcbf49743123774b00494c824ce1464c7c1db0196f971d7cd4e0a0b3213c705892fa9202236f817435ebc9bf705d2231a87cd319367e73e756abbd2e5f7b3bcb13fd9f21195637dc088620bb87f613850a0dba5a3b6ba199139f9364abd512371e20653a85026e5191950579c5e014efe11e31729adc5a38380c369efcd070cd80af530b871a8ef20e48f17d6f3a49b2e8b8ae20298d9a30391bc4b0097cf253d07e425347ae8d5252573217d03d955383b67df9de6d890e686f23a45fc0810a4fa04d090df4e92f457e8cbe2e816758d96479db9d9ff4e261f68921a23fae7ee86e13aec911e318334e2a8273c9d77547184e7e09cb56013c600a97d2c99bfd05d6595afe7dc3a07f5aa662c424d095e5a69d3b447099e690cdbd0dfdb0e91615a861e78da68c4db0e2336ffe7a808abe419e205950dc7f9a77ad556f8d93f13ba28fe8f86c3fc9a7c723dd6e1aece927cd95db531a2824341742245be5d334d6d64633d6cfeb80a4610fcbe45c051f472a4d41624453fd6322377fb2d37114556ec77075b0055974150579b0e61c2ab76411821f4917db212a880f58503a1973e8101f5551f2dc02aeab177e026ec8b94a50303dccd0b9f79b79c47e90529bbe4f618806f465433ef01daa0a2788d552a932d7c9c17d8550edfb7e6b39fc14540290a1adbfc8c10e43e9d81cbaa92fdea1176cb6f1d1f2b24595c5e5e888fd023f14ce3fbd74aec7ff4c953b280fdf4ad1af3c61a55945355f08e91c5697d6c18f6eb4e026d2deb51c0d855f72cf6f1558c68612406ab537d093b28642d97b08db079868fc5fb056a7552349c7947292b6674b9b55ea543115a6394f3e55bc53793f8593506246ebc1020afb9f23de08047f2c514d373143b0c13ba97e90ba6b027368987df037e1db694b05b2c3537047d091c95b89138fdc68f69df16ee720799421739c28480d9ecf6e77abc9440b445ea9694cf59b19407d24d0ce765e15d841fa9061ef57686f71db8e36b0e6b17cb5e64835fb4db64c3d1c9898988f2991e820f3a46ec214af03c8729b3f1eea633914eb9d5494c32389e9bf9a881adb6c7095d974b6b3f96d41d088c";
static const uint256 MainnetHashMerkleRoot = uint256S("db59ee80098a38c8251e96e5358eeeb80f5c4e64790727803cab828fed0a9368");
static const uint256 MainnetHashGenesisBlock = uint256S("000081da84af725f5b4281b9a42d251f06715f14b86cb4cf9e59c2b9cf88b7eb");

static const std::string TestnetNonce = "0000000000000000000000000000000000000000000000000000000000000025";
static const std::string TestnetSolution = "008c182882d3e546b05bf5c93b669b81f81d1715a310295f26e21f69af5050c133b745c285432c786b89170113757f8f9a5c876f62d30ae7335f546b5dc48f3c838e70558f66a1324644ae0af83006cf3ff9a9fa08c134b2178d4169f3a283d84054678681d77bfd20124501140310781ed2cc6256bcef194cb58dab2eac0bca87adb6d8f690e871b136fd3b2628e5d58c66221fe9e555facb32a07f34b682c2f987da795fba09920beab08ffc8af465744db6afba4859fde438d22fb81d4f91e2c5e1be091d9643124c68cc95c94633cbf11ecfb60626683a2d7426d544ee6a9f3e11513b08704544aee4a7956bef622ff7d72dee614e3974d2981212ae016c31466769a58e85cbf46955e1922b5515e3314ab6b5cf9e5f17640c5545ddfcbb0671b89b1259176003f8276ca98f8986317ffcb6f65c8f927fd0b9326416006b154c0ebeea7afeade9590ac0c158f46e068b29536697988ba1b253ee9237d0ef0394fd50c038114eeb5352c4d0d49803ee82fa90a10c03cd3df611d3f5c56c0eff17db59e34143cbb568eb67cdd1a8213a448d342d9f9dedc396ae1efed1e5e9deb5892b122bfacf00507b0c89a671763a210afc9ce1341ca5152d6afebb126f30efaab1d1743ae06a34e5d8baec1a4fb1219330866dec45529a5a2a96b94b7d94faa44aaf7772d8601493b82b784a92c70e763874d60d4806bf4349988fc1b0fbfd2585442c6be9a1ad96d54823a7c685fe9b99d2e07d8b3159efe1b2eba2faa6d31a982e724b10415b9c8592dbf0d469c1762a718bc2308bd30729d68463113236e683cdc495d90a373be90b4b432159db23275909c5cf793c3c19a9c03c51a0222592fd9911b3739b3168bab9eb2b7662eb3d502a456f768b91a8d033d534b457d53d1d0630a614c1045710baf8269bbad52a1275bec8f8dafe332f760cdb019ccc21981d21db45ebd4da0dfec989591d4d0b9f15bb5b7dd9aa8745afa3253ee044fefe68bdb72dbf23274755d488cf46b958e350d8d6c4b2878d15f94624d78519a0e2be2d4dd7d6025c6b3a75cee82e9d500438693a4ddcb2594a34462701e843b9e7b0b61ddb06d1c8d33d13c54d885d206d934443a26f545b3424384dbe70cc2582ab3c3ad69e6bbd45c1b6837365b43959fe6fb1af942ff52967fcb9766fe250f958b343036ce6019a57f47b49ae47c60853ab128ed0d879ce154fec8be990c41dff2c42287b9944a544cd4d00e4376bb6c70418ef18fd41156dfab551bdc8fab1a7ea468acf3f39ad572fceb79a33975c498334f4fff17a03de24c9b00e7ac5e3fff357823b03d10c221755d82941e320fbd7c8e127e8e34f99529bc917f316b70006dae2116fc8c761fa34a0ec6918408c51a2f2efa52eb76ce1daf6fc03eedf72fbedde274ebb077a22b901bca3a1bd116fc924642601867135134a665e1784481b82c186e29ebdb7f87650e3ef2276160312e42e07bf22ef5d936bc5a4f63c703dfc4bb32d557f4e400e6feec6d0893e38acb0039c39d8d312a36d5b5e0d072d8b6f3ea380cbc8cd808f00f2b5a8bb6271e1d30ac36918134741e19e8840ec834bf37471284d0eda265f648a38189d17c3b8b299dee28a06b109df70545083e305fa5ba589e4bab93b69d8e86b806ffec86b04e180919e9ce05eee7bf2bb70b5f4e5cc16f500ea15e3de802b91767abf48583dea6e9faf77a35e890309924645fe9d5f65171b63d797f475eee236fbed8713e0e2b217ce24fcd1b1a4352456e75da0d079defd07e8b1efdb4b324ca4292431afe6b621b255fc0dad5ffc8d6e435ac0af1bd937339dcfb2dedd54dc1beb103499dededfc9312a4a962bc0c5622337d15c510845e134c38f26fd9d8ad378a4346bb0d6bd87b8dd1d";
static const uint256 TestnetHashGenesisBlock = uint256S("0302f1ab449e6424f1ec076a6496b331fa664d8b95d866023ea6675bbb387f53");

static const std::string RegtestNonce = "0000000000000000000000000000000000000000000000000000000000000039";
static const std::string RegtestSolution = "07b461d5f48e91b1fe4a65a112b513c1ad230a9bd4b8f79c069da636341051b3ff455393";
static const uint256 RegtestHashGenesisBlock = uint256S("065c1d8ea9abb121b8b12e4e483e46f60e743bb149de4bc82e4dd81598b99338");

static CBlock CreateMainnetGenesisBlock()
{
    uint32_t nTime = EpocTime;
    uint32_t nBits = 0x1f07ffff;

#ifdef MINE_GENESIS_MAIN
    uint256 nNonce = uint256S("0");
    v_uint8 nSolution = ParseHex("0");
#else
    uint256 nNonce = uint256S(MainnetNonce);
    v_uint8 nSolution = ParseHex(MainnetSolution);
#endif

    CBlock block = CreateGenesisBlock(PastelGenesisTimestamp, PastelGenesisPubKey, EpocTime, nNonce, nSolution, nBits);

#ifdef MINE_GENESIS_MAIN
    MineGenesis::__mineGenBlock("MainNet", true, 200, 9, &block);
#endif

    return block;
}

static CBlock CreateTestnetGenesisBlock()
{
    uint32_t nTime = EpocTime;
    uint32_t nBits = 0x2007ffff;

#ifdef MINE_GENESIS_TEST
    uint256 nNonce = uint256S("0");
    v_uint8 nSolution = ParseHex("0");
#else
    uint256 nNonce = uint256S(TestnetNonce);
    v_uint8 nSolution = ParseHex(TestnetSolution);
#endif

    CBlock block = CreateGenesisBlock(PastelGenesisTimestamp, PastelGenesisPubKey, EpocTime, nNonce, nSolution, nBits);

#ifdef MINE_GENESIS_TEST
    MineGenesis::__mineGenBlock("TestNet", true, 200, 9, &block);
#endif
    return block;
}

static CBlock CreateRegtestGenesisBlock()
{
    uint32_t nTime = EpocTime;
    uint32_t nBits = 0x200f0f0f;

#ifdef MINE_GENESIS_REGT
    uint256 nNonce = uint256S("0");
    v_uint8 nSolution = ParseHex("0");
#else
    uint256 nNonce = uint256S(RegtestNonce);
    v_uint8 nSolution = ParseHex(RegtestSolution);
#endif

    CBlock block = CreateGenesisBlock(PastelGenesisTimestamp, PastelGenesisPubKey, EpocTime, nNonce, nSolution, nBits);

#ifdef MINE_GENESIS_REGT
    MineGenesis::__mineGenBlock("RegTest", false, 48, 5, &block);
#endif

    return block;
}

/**
 * Main network
 */
/**
 * What makes a good checkpoint block?
 * + Is surrounded by blocks with reasonable timestamps
 *   (no blocks before with a timestamp after, none after with
 *    timestamp before)
 * + Contains no strange transactions
 */

const arith_uint256 maxUint = UintToArith256(uint256S("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

class CMainParams : public CChainParams {
public:
    CMainParams() {
        strNetworkID = "main";
        network = CBaseChainParams::Network::MAIN;
        strCurrencyUnits = "PSL";
        bip44CoinType = 133; // As registered in https://github.com/patoshilabs/slips/blob/master/slip-0044.md
        consensus.nSubsidyHalvingInterval = 840'000;
        consensus.nMajorityEnforceBlockUpgrade = 750;
        consensus.nMajorityRejectBlockOutdated = 950;
        consensus.nMajorityWindow = 4000;
        consensus.powLimit = uint256S("0007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        consensus.nPowAveragingWindow = 17;
        assert(maxUint/UintToArith256(consensus.powLimit) >= consensus.nPowAveragingWindow);
        consensus.nPowMaxAdjustDown = 32; // 32% adjustment down
        consensus.nPowMaxAdjustUp = 16; // 16% adjustment up
        consensus.nPowTargetSpacing = static_cast<int64_t>(2.5 * 60);
        consensus.nPowAllowMinDifficultyBlocksAfterHeight = std::nullopt;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nActivationHeight = Consensus::NetworkUpgrade::ALWAYS_ACTIVE;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nProtocolVersion = 170005;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nActivationHeight = OVERWINTER_STARTING_BLOCK;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nProtocolVersion = 170007;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nActivationHeight = SAPLING_STARTING_BLOCK;
        consensus.nMaxGovernanceAmount = 100'000'000*COIN;

        // The best chain should have at least this much work.
        consensus.nMinimumChainWork = uint256S("000000000000000000000000000000000000000000000000000000000624f116"); //2702
        
        /**
         * The message start string
         */
        pchMessageStart[0] = 0x6b;
        pchMessageStart[1] = 0xda;
        pchMessageStart[2] = 0xb8;
        pchMessageStart[3] = 0xfc;
        vAlertPubKey = ParseHex("0441f3821b035bc418b8fbe8e912005112826a5c51fdcf5fbac6d7dd2ab545183049e51c3f2ed2a70b1e48a59b4c3367c15d30fbff461afc6b83932fefedfe5d41");
        nDefaultPort = MAINNET_DEFAULT_PORT;
        nPruneAfterHeight = 100'000;
        const size_t N = 200, K = 9;
        BOOST_STATIC_ASSERT(equihash_parameters_acceptable(N, K));
        consensus.nEquihashN = N;
        consensus.nEquihashK = K;

        genesis = CreateMainnetGenesisBlock();
        consensus.hashGenesisBlock = genesis.GetHash();
#ifndef MINE_GENESIS
        assert(consensus.hashGenesisBlock == MainnetHashGenesisBlock);
        assert(genesis.hashMerkleRoot == MainnetHashMerkleRoot);
#endif

        vFixedSeeds.clear();
        vSeeds.clear();
        vSeeds.push_back(CDNSSeedData("pastel.network", "dnsseed.pastel.network"));

        // guarantees the first 2 characters, when base58 encoded, are "Pt"
        m_base58Prefixes[to_integral_type(Base58Type::PUBKEY_ADDRESS)] = {0x0c, 0xe3};
        // guarantees the first 2 characters, when base58 encoded, are "pt"
        m_base58Prefixes[to_integral_type(Base58Type::SCRIPT_ADDRESS)] = {0x1a, 0xF6};
        // the first character, when base58 encoded, is "5" or "K" or "L" (as in Bitcoin)
        m_base58Prefixes[to_integral_type(Base58Type::SECRET_KEY)] = {0x80};
        // do not rely on these BIP32 prefixes; they are not specified and may change
        m_base58Prefixes[to_integral_type(Base58Type::EXT_PUBLIC_KEY)] = {0x04, 0x88, 0xB2, 0x1E};
        m_base58Prefixes[to_integral_type(Base58Type::EXT_SECRET_KEY)] = {0x04, 0x88, 0xAD, 0xE4};
        // guarantees the first 2 characters, when base58 encoded, are "Pz"
        m_base58Prefixes[to_integral_type(Base58Type::ZCPAYMENT_ADDRESS)] = {0x09, 0x05};
        // guarantees the first 4 characters, when base58 encoded, are "Px"
        m_base58Prefixes[to_integral_type(Base58Type::ZCVIEWING_KEY)] = {0x09, 0x01};
        // guarantees the first 2 characters, when base58 encoded, are "Ps"
        m_base58Prefixes[to_integral_type(Base58Type::ZCSPENDING_KEY)] = {0x9A, 0x90};

        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_PAYMENT_ADDRESS)] = "ps";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_FULL_VIEWING_KEY)] = "pviews";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_INCOMING_VIEWING_KEY)] = "pivks";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_EXTENDED_SPEND_KEY)] = "p-secret-extended-key-main";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_EXTENDED_FVK)] = "pxviews";

 //       vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));

        fMiningRequiresPeers = true;
        fDefaultConsistencyChecks = false;
        fRequireStandard = true;
        fMineBlocksOnDemand = false;
        fTestnetToBeDeprecatedFieldRPC = false;

        checkpointData.mapCheckpoints = {
            { 0,        consensus.hashGenesisBlock },
            // 1612317919: Tuesday, February 2, 2021 9:05:19 PM GMT-05:00
            // tx: 3588; txPerDay: 800 (actual - 765)
            { 2'700,    uint256S("00005558df2a688c6d53c7b78001074515d33cd29589a311f8c6aa4db2df4e44") },
            // 1648076650: Wednesday, March 23, 2022 7:04:10 PM GMT-04:00
            // tx: 457'181; txPerDay: 1120
            { 237'200,  uint256S("0000000230338b9476ae927240f6d96be57e3f85a8169ede6ec654823757acd7") }
        };
        checkpointData.nTimeLastCheckpoint = 1648076650; // * UNIX timestamp of last checkpoint block
        checkpointData.nTransactionsLastCheckpoint = 457'181; // * total number of transactions between genesis and last checkpoint
                                //   (the tx=... number in the UpdateTip debug.log lines - "UpdateTip: new best=... tx=...")
        checkpointData.fTransactionsPerDay = 1120; // * estimated number of transactions per day after checkpoint
                                //   total number of tx / (checkpoint block height / (24 * 24))
    }
};

/**
 * Testnet (v3)
 */
class CTestNetParams : public CChainParams {
public:
    CTestNetParams() {
        strNetworkID = "test";
        network = CBaseChainParams::Network::TESTNET;
        strCurrencyUnits = "LSP";
        bip44CoinType = 1;
        consensus.nSubsidyHalvingInterval = 840'000;
        consensus.nMajorityEnforceBlockUpgrade = 51;
        consensus.nMajorityRejectBlockOutdated = 75;
        consensus.nMajorityWindow = 400;
        consensus.powLimit = uint256S("07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        consensus.nPowAveragingWindow = 17;
        assert(maxUint/UintToArith256(consensus.powLimit) >= consensus.nPowAveragingWindow);
        consensus.nPowMaxAdjustDown = 32; // 32% adjustment down
        consensus.nPowMaxAdjustUp = 16; // 16% adjustment up
        consensus.nPowTargetSpacing = static_cast<int64_t>(2.5 * 60);
        consensus.nPowAllowMinDifficultyBlocksAfterHeight = 299'187;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nActivationHeight = Consensus::NetworkUpgrade::ALWAYS_ACTIVE;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nProtocolVersion = 170003;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nActivationHeight = OVERWINTER_STARTING_BLOCK;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nProtocolVersion = 170007;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nActivationHeight = SAPLING_STARTING_BLOCK;
        consensus.nMaxGovernanceAmount = 1'000'000*COIN;

        // The best chain should have at least this much work.
        consensus.nMinimumChainWork = uint256S("0x00");

        /**
         * The message start string
         */
        pchMessageStart[0] = 0x38;
        pchMessageStart[1] = 0xb6;
        pchMessageStart[2] = 0xfe;
        pchMessageStart[3] = 0x64;
        vAlertPubKey = ParseHex("0429aff40718031ed61f0166f3e33b5dfb256c78cdbfa916bf6cc9869a40ce1d66ca35b92fe874bd18b69457ecef27bc3a0f089b737b03fb889dc1420b6a6e70cb");
        nDefaultPort = TESTNET_DEFAULT_PORT;
        nPruneAfterHeight = 1000;
        const size_t N = 200, K = 9;
        BOOST_STATIC_ASSERT(equihash_parameters_acceptable(N, K));
        consensus.nEquihashN = N;
        consensus.nEquihashK = K;

        genesis = CreateTestnetGenesisBlock();
        consensus.hashGenesisBlock = genesis.GetHash();
#ifndef MINE_GENESIS
        assert(consensus.hashGenesisBlock == TestnetHashGenesisBlock);
#endif

        vFixedSeeds.clear();
        vSeeds.clear();
        vSeeds.push_back(CDNSSeedData("pastel.network", "dnsseed.testnet.pastel.network"));

        // guarantees the first 2 characters, when base58 encoded, are "tP"
        m_base58Prefixes[to_integral_type(Base58Type::PUBKEY_ADDRESS)] = {0x1C, 0xEF};
        // guarantees the first 2 characters, when base58 encoded, are "tt"
        m_base58Prefixes[to_integral_type(Base58Type::SCRIPT_ADDRESS)] = {0x1D, 0x37};
        // the first character, when base58 encoded, is "9" or "c" (as in Bitcoin)
        m_base58Prefixes[to_integral_type(Base58Type::SECRET_KEY)] = {0xEF};
        // do not rely on these BIP32 prefixes; they are not specified and may change
        m_base58Prefixes[to_integral_type(Base58Type::EXT_PUBLIC_KEY)] = {0x04, 0x35, 0x87, 0xCF};
        m_base58Prefixes[to_integral_type(Base58Type::EXT_SECRET_KEY)] = {0x04, 0x35, 0x83, 0x94};
        // guarantees the first 2 characters, when base58 encoded, are "tZ"
        m_base58Prefixes[to_integral_type(Base58Type::ZCPAYMENT_ADDRESS)] = {0x14, 0x3A};
        // guarantees the first 4 characters, when base58 encoded, are "tX"
        m_base58Prefixes[to_integral_type(Base58Type::ZCVIEWING_KEY)] = {0x14, 0x37};
        // guarantees the first 2 characters, when base58 encoded, are "tQ" OR "tS"
        m_base58Prefixes[to_integral_type(Base58Type::ZCSPENDING_KEY)] = {0x05, 0xFE};

        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_PAYMENT_ADDRESS)] = "ptestsapling";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_FULL_VIEWING_KEY)] = "pviewtestsapling";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_INCOMING_VIEWING_KEY)] = "pivktestsapling";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_EXTENDED_SPEND_KEY)] = "p-secret-extended-key-test";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_EXTENDED_FVK)] = "pxviewtestsapling";

        // vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));

        fMiningRequiresPeers = true;
        fDefaultConsistencyChecks = false;
        fRequireStandard = true;
        fMineBlocksOnDemand = false;
        fTestnetToBeDeprecatedFieldRPC = true;


        checkpointData.mapCheckpoints = {{0, consensus.hashGenesisBlock}};
        checkpointData.nTimeLastCheckpoint = genesis.nTime; // * UNIX timestamp of last checkpoint block
        checkpointData.nTransactionsLastCheckpoint = 0;     // * total number of transactions between genesis and last checkpoint
                                //   (the tx=... number in the SetBestChain debug.log lines)
        checkpointData.fTransactionsPerDay = 250;           // * estimated number of transactions per day after checkpoint
                                //   total number of tx / (checkpoint block height / (24 * 24))
    }
};

/**
 * Regression test
 */
class CRegTestParams : public CChainParams {
public:
    CRegTestParams()
    {
        strNetworkID = "regtest";
        network = CBaseChainParams::Network::REGTEST;
        strCurrencyUnits = "REG";
        bip44CoinType = 1;
        consensus.nSubsidyHalvingInterval = 150;
        consensus.nMajorityEnforceBlockUpgrade = 750;
        consensus.nMajorityRejectBlockOutdated = 950;
        consensus.nMajorityWindow = 1000;
        consensus.powLimit = uint256S("0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f");
        consensus.nPowAveragingWindow = 17;
        assert(maxUint/UintToArith256(consensus.powLimit) >= consensus.nPowAveragingWindow);
        consensus.nPowMaxAdjustDown = 0; // Turn off adjustment down
        consensus.nPowMaxAdjustUp = 0; // Turn off adjustment up
        consensus.nPowTargetSpacing = static_cast<int64_t>(2.5 * 60);
        consensus.nPowAllowMinDifficultyBlocksAfterHeight = 0;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::BASE_SPROUT].nActivationHeight = Consensus::NetworkUpgrade::ALWAYS_ACTIVE;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nProtocolVersion = 170002;
        consensus.vUpgrades[Consensus::UPGRADE_TESTDUMMY].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nProtocolVersion = 170003;
        consensus.vUpgrades[Consensus::UPGRADE_OVERWINTER].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nProtocolVersion = 170008;
        consensus.vUpgrades[Consensus::UPGRADE_SAPLING].nActivationHeight = Consensus::NetworkUpgrade::NO_ACTIVATION_HEIGHT;
        consensus.nMaxGovernanceAmount = 1'000'000*COIN;

        // The best chain should have at least this much work.
        consensus.nMinimumChainWork = uint256S("0x00");

        /**
         * The message start string
         */
        pchMessageStart[0] = 0xcd;
        pchMessageStart[1] = 0xd8;
        pchMessageStart[2] = 0xfa;
        pchMessageStart[3] = 0x9e;
        vAlertPubKey = ParseHex("04b985ccafe6d17ac5d84cb8c06a69cefad733ee96b4b93bcf5ef0897778c227ee7e74e7680cc219236e4c6a609dbcdeb5bf65cea9c2576c2a0fbef590657c8e7a");
        nDefaultPort = REGTEST_DEFAULT_PORT;
        nPruneAfterHeight = 1000;
        const size_t N = 48, K = 5;
        BOOST_STATIC_ASSERT(equihash_parameters_acceptable(N, K));
        consensus.nEquihashN = N;
        consensus.nEquihashK = K;
        
        genesis = CreateRegtestGenesisBlock();
        consensus.hashGenesisBlock = genesis.GetHash();
#ifndef MINE_GENESIS
        assert(consensus.hashGenesisBlock == RegtestHashGenesisBlock);
#endif

        vFixedSeeds.clear(); //! Regtest mode doesn't have any fixed seeds.
        vSeeds.clear();  //! Regtest mode doesn't have any DNS seeds.

        // These prefixes are the same as the testnet prefixes
        // guarantees the first 2 characters, when base58 encoded, are "tP"
        m_base58Prefixes[to_integral_type(Base58Type::PUBKEY_ADDRESS)] = {0x1C, 0xEF};
        // guarantees the first 2 characters, when base58 encoded, are "tt"
        m_base58Prefixes[to_integral_type(Base58Type::SCRIPT_ADDRESS)] = {0x1D, 0x37};
        // the first character, when base58 encoded, is "9" or "c" (as in Bitcoin)
        m_base58Prefixes[to_integral_type(Base58Type::SECRET_KEY)] = {0xEF};
        // do not rely on these BIP32 prefixes; they are not specified and may change
        m_base58Prefixes[to_integral_type(Base58Type::EXT_PUBLIC_KEY)] = {0x04, 0x35, 0x87, 0xCF};
        m_base58Prefixes[to_integral_type(Base58Type::EXT_SECRET_KEY)] = {0x04, 0x35, 0x83, 0x94};
        // guarantees the first 2 characters, when base58 encoded, are "tZ"
        m_base58Prefixes[to_integral_type(Base58Type::ZCPAYMENT_ADDRESS)] = {0x14, 0x3A};
        // guarantees the first 4 characters, when base58 encoded, are "tX"
        m_base58Prefixes[to_integral_type(Base58Type::ZCVIEWING_KEY)] = {0x14, 0x37};
        // guarantees the first 2 characters, when base58 encoded, are "tQ" OR "tS"
        m_base58Prefixes[to_integral_type(Base58Type::ZCSPENDING_KEY)] = {0x05, 0xFE};

        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_PAYMENT_ADDRESS)] = "pzregtestsapling";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_FULL_VIEWING_KEY)] = "pviewregtestsapling";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_INCOMING_VIEWING_KEY)] = "pivkregtestsapling";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_EXTENDED_SPEND_KEY)] = "p-secret-extended-key-regtest";
        m_bech32HRPs[to_integral_type(Bech32Type::SAPLING_EXTENDED_FVK)] = "pxviewregtestsapling";

        fMiningRequiresPeers = false;
        fDefaultConsistencyChecks = true;
        fRequireStandard = false;
        fMineBlocksOnDemand = true;
        fTestnetToBeDeprecatedFieldRPC = false;

        checkpointData.mapCheckpoints = {{0, consensus.hashGenesisBlock}};
        checkpointData.nTimeLastCheckpoint = genesis.nTime;
        checkpointData.nTransactionsLastCheckpoint = 0;
        checkpointData.fTransactionsPerDay = 0;
    }

    void UpdateNetworkUpgradeParameters(Consensus::UpgradeIndex idx, const int nActivationHeight)
    {
        assert(idx > Consensus::BASE_SPROUT && idx < Consensus::MAX_NETWORK_UPGRADES);
        consensus.vUpgrades[idx].nActivationHeight = nActivationHeight;
    }
};

// global blockchain parameters
static std::unique_ptr<const CChainParams> globalChainParams;

const CChainParams &Params()
{
    assert(globalChainParams);
    return *globalChainParams;
}

/**
 * Create blockchain parameters based on network type.
 * 
 * \param network - MAIN, TESTNET or REGTEST
 * \return unique_ptr with chain parameters
 */
std::unique_ptr<const CChainParams> CreateChainParams(const CBaseChainParams::Network network)
{
    std::unique_ptr<CChainParams> ChainParams;
    switch (network)
    {
        case CBaseChainParams::Network::MAIN:
            ChainParams = std::make_unique<CMainParams>();
            break;

        case CBaseChainParams::Network::TESTNET:
            ChainParams = std::make_unique<CTestNetParams>();
            break;

        case CBaseChainParams::Network::REGTEST:
            ChainParams = std::make_unique<CRegTestParams>();
            break;

        default:
            assert(false && "Unimplemented network");
            ChainParams = std::make_unique<CMainParams>();
            break;
    }
    return std::move(ChainParams);
}

/**
 * Sets the params returned by Params() to those for the given network.
 * 
 * \param network - blockchain network type (MAIN, TESTNET or REGTEST)
 */
void SelectParams(const CBaseChainParams::Network network)
{
    SelectBaseParams(network);
    globalChainParams = CreateChainParams(network);
}

bool SelectParamsFromCommandLine()
{
    CBaseChainParams::Network network = NetworkIdFromCommandLine();
    if (network == CBaseChainParams::Network::MAX_NETWORK_TYPES)
        return false;

    SelectParams(network);
    return true;
}

void UpdateNetworkUpgradeParameters(Consensus::UpgradeIndex idx, const int nActivationHeight)
{
    if (globalChainParams && globalChainParams->IsRegTest())
    {
        auto RegTestParams = const_cast<CRegTestParams*>(dynamic_cast<const CRegTestParams*>(globalChainParams.get()));
        if (RegTestParams)
            RegTestParams->UpdateNetworkUpgradeParameters(idx, nActivationHeight);
    }
}
